# Go 语言实战

[git地址](https://github.com/goinaction/code)

## 第一章

### 优势

- 开发快，运行速度快，编译快
- 能很容易的把耗时任务交给goroutine执行，相当于执行批量任务

### 赋值

- page 42，一个很有意思的东西，go语言的调用：定义接口，定义并绑定接口的实现，再把定义的变量赋值给接口，最后通过接口进行调用
  - go语言的赋值操作感觉做了几个事情，如果是指针赋值，则直接赋值，如果是结构体赋值则解析为值赋值
  - 所以当把结构体直接赋值给接口的时候实际是复制了一遍接口体，再进行赋值的

## 第二章

### 包管理

- 通过govender对包的依赖进行管理

### 第四章

- page 79，go真是个奇怪的语言，所以等值判断语句是值比较？不同类型也能做值比较？

```go
	var a []int
	fmt.Println(len(a))
	fmt.Println(a == nil) // true
	fmt.Println(len(nil)) // len不能接受nil参数
```

- go的接口，go并不像python，没有类型限制，函数定义的时候就需要指定类型，可以指定一个空接口，类似java的Object类？不全类似，实际上是定义好接口的方法，传递参数的时候传递一个实现了接口的对象去调用
- 接口调用
  - 接口，一个指向类型方法集的指针，一个指向具体值
  - 方法集中实现的接口方法有一个方法接收者，方法接收者与类型之间有一个对应关系
  - 接口-方法接收者与类型对应表，值类型的方法接收者能值类型和指针类型的对象，指针类型的只能接收指针类型的对象
  - 对于值类型的调用，go首先会复制调用的对象，函数调用的对象实际是复制的对象，不会产生状态修改
    - 即使是指针也不行，因为复制的是指针同样会复制一遍指针指向的区域
- goroutine调用的坑
  - goroutine在调度的时候即使是cpu密集型的函数，没有阻塞，只是调用了别的函数也会引起goroutine的调度？
- go中并发中的三种并发控制
- atomic，适合操作同步资源很快的操作
  - AddInt64，spin_lock，所有线程都尝试进入临界区
  - StoreInt64和LoadInt64，当go会把这些操作同步的执行，即调整先后执行的顺序不发生竞态
- mutex，WaitGroup
- channel

- goroutine管理
  - runner，实现对goroutine的超时，运行完成，信号中断管理
  - pool，实现了一个资源池管理器，通过pool获取、释放资源，释放的资源不会立即关闭，而是放回池中，池子满了则关闭资源，获取资源通过通道获取，如果通道中没有资源则创建新资源
  - work，通过一个channel同步任务，类似python的Queue，通过修改缓冲区大小使得适合cpu型或io型应用
- go可以任意绑定方法到某个类型上，结合接口可以完成更加高效的工作
- 通过benchmark测试哪个函数更快

## 想法

- go语言的设计模式完全不一样

