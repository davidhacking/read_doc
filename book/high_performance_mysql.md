# High performance mysql



### MySQL

- 基础设施组件

### 架构

- 第一层：连接层
  - 连接池：一个连接对应一个线程（NIO实现方式？）
  - 权限控制：db级、表级权限控制（缓存导致不生效的坑）
- 第二层：逻辑层
  - 解析器、优化器：可以使用explain查看mysql是如何优化的，通过hint的方式决定优化器的决策过程
    - 优化器居然会收集表数据的统计信息进行优化，而不关心是哪个存储引擎
  - 缓存：对解析结果和优化结果的缓存，对于一个已经解析的SQL语句会从缓存在直接获取结果
  - 并发控制（逻辑层）：
    - 锁，锁的管理本身就消耗着系统资源，包括获取锁、检查锁状态和释放锁
    - 锁队列用于管理读锁和写锁，
    - 表锁，非Innodb引擎支持read local锁在一个表read时进行数据修改，管理锁的成本最低
    - 行锁，锁开销最大，是现在引擎层
- 第三层：引擎层，mysql本身提供的：Innodb和NDB Cluster，第三方的：XtraDB和PBXT都是支持事务的引擎
  - 并发控制（引擎层）
  - 持久化：为每个schema在工作目录中分配一个子目录，frm保存表定义（每个table一个），

## 基本特性

### 事务与ACID

- 事务就是原子操作的一组SQL语句
  - 使用START TRANSACTION开始一个事务，COMMIT提交一个事务
  - 某些命令会强制提交当前事务，比如ALTER TABLE
  - 事务实现在引擎层，可以同时拥有MyISAM和Innodb的表，但是在数据回滚时MyISAM上修改的数据不会被回滚
  - Innodb为每个事务隐式加锁，在COMMIT或ROLLBACK的时候释放锁
  - 事务满足ACID四个性质
- 原子性（atomic）
- 一致性（consistency），数据库总是从一个一致性的状态转移到另一个一致性状态
- 隔离性（isolation），通常来说一个事务提交前的所有操作对于另一个事务是不可见的，通常来说很关键，因为这和你所使用的隔离级别有关
- 持久性（durability），事务提交后事务做的修改会提交到磁盘上做持久化
- 隔离级别
  - read uncommitted，读未提交
  - read commited，读提交，如果事务A在事务B执行的过程中执行，那么A会发生不可重复读的现象
  - read repeatable，可重复读，无法避免幻读现象，~~可重复读实际是通过锁住之前读的行来保证其他事务无法修改这些行~~（这只是我的想法，不知道一般化的实现，mysql通过MVCC肯定不是这样实现），但不能保证其他事务不插入数据，所以可能幻读到插入的数据，Innodb通过MVCC解决了此问题，因为我只读时间版本在我事务开始前的修改
  - serializable，串行化读取，在读取的每一行数据上都加锁，~~难道不是没有并发了，单线程完成每一个事务吗？~~

- MVCC
  - mysql的Innodb通过MVCC来不加锁实现RR
  - mysql为每一行数据添加三个自动，DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID，这三个字段可以表示两个含义：数据的创建时间和数据的删除时间
  - select，事务的开始时间>数据的创建时间，事务的开始时间<数据的删除时间，这些数据都是对该事务可见的
  - insert，把自己的版本号设置为创建时间
  - delete，把自己的版本号设置为删除时间
  - update，同时做insert和delete两个操作

- 死锁，当两个事务发生死锁时，Innodb会检测到死锁，并把其中一个持有锁最少的事务回滚
  - 回滚后的事务需要应用程序重新执行一遍，当然可以有自己的处理逻辑
- WAL机制，mysql使用WAL机制实现事务的持久化，持久化时先写内存，再由线程把内存中的数据持久化到事务日志（写日志时其实是追加方式写的，所以很快），并写数据库文件

## Schema与数据类型优化

逻辑设计、物理设计和查询设计

- 对于能够索引的列最好使用NOT NULL定义，不然NULL值其实会在索引时产生而外开销
- 只是用基本类型，数字、字符串、时间，mysql使用了很多别名，如bool其实和int是一个意思，区别只是在于合法性校验
- decimal采用bigint优化，例如需要精确到小数点后6位，可以x10^6后存bigint，decimal类型本身不支持CPU直接运算，mysql自己实现了一波decimal的高精度计算
- float，7个有效位，double，15个有效位，decimal，28个有效位
- varchar，在update varchar字段时，由于数据是变长的，Innodb会采用分裂页的方式来使行能放入页中
  - 适用于字符串的最大长度比平均长度大很多
  - varchar5和varchar200在存储hello时用的空间是一样的，但是varchar5能让mysql在排序和索引过程中有更加优秀的表现
- char（page152），在填充char字段的时候由于使用空格进行填充，所以存的时候是空格结尾，则空格会产生截断的感觉

### B-Tree

- m阶的btree最多有m-1个孩子，最少有⌈m/2⌉个孩子，因为m阶最多有m个child

- 插入：尝试插入到子节点上，如果插入后子节点上key的数量不超过m个则插入完成，超过则分裂子节点，并递归插入**中间的数**到父节点上（父节点也满了则递归分裂）
  - 所以在数据量很大的时候插入，真的有可能使插入的成本贼高
- 删除：
- hash索引，在B-Tree上建立自适应hash，hash索引实际是对某一列做的一次hash，这样能够在等值判断的时候直接找到行数据，mysql会对于经常被访问的行数据在B-Tree索引的基础上做hash索引
  - 对url这种数据进行等值查找的时候非常慢，优化方法：插入一个hash索引（page185）

### R-Tree

- 空间索引，MyISAM支持，地理数据的索引

### 全文索引

### 前缀索引page190

- 对varchar字段或blob、text字段采用前缀索引的方式，达到即可以过滤更多的行又可以节省索引空间的目的
- 前缀索引选择多少字节合适？1. 计算索引列的distinct值与总数的比值A 2. 尝试2、3、5和7等个数的前缀与总数的比值，比较比值的增长情况，例如：从5到7比值已经比较接近A了，那其实就选择5就行了
- 添加某列的前缀索引，alter table table add key (col(PREFIX_LEN))
- 前缀索引并不能做order by和group by，也无法做覆盖扫描
- 后缀索引，通过把前缀索引反向存储一遍

### 如果建立高效索引page194

- where条件中的and的字段，采用联合索引，即一个包含多列的索引
- where条件中的or的字段，这个并不是采用独立索引就好了，因为涉及到数据排序与合并，mysql会将数据进行合并，如果没写好mysql会全表扫描
  - 老版本：A or B = A or (B and ~A)通过两个sql查询出来再将结果合并，这样mysql才会使用索引
  - 新版本：mysql可以帮你完成老版本的功能，不需要你写难懂的sql，但做法是一样的
  - 可以通过explain sql\G的Extra字段查看mysql是怎么处理的，有没有用你的索引，三种做法：union、intersection和两者组合
- 作者最后评价，mysql做的这个优化合并索引还不如自己写union sql，经常出了问题查不了，关闭方法：optimizer_switch，或在查询时通过ignore index的方式忽略掉某些索引

### Innodb

- page53，RR的实现机制，通过next-key locking（间隙锁）策略防止行的插入，即锁定了查询的数据和索引
- 聚簇索引，索引数据与行数据按顺序关联存储，非聚簇索引，索引中存放行数据所在地址
  - 有点，减少磁盘IO
- 自适应hash索引，如果某个二级索引被频繁访问则会建立hash索引提升访问速度
- 不支持热备份

### MyISAM

- 不支持事务，无法安全恢复
- 加锁，对表加锁，加写锁的表可以完成concurrent insert
- 存储，数据文件（myd）和索引文件（myi），支持表压缩
- 支持对blob和text前500个字符创建索引

### NDB

- mysql集群

### 命令

- 查看表状态，show table status

  - row_format，Dynamic表示行中包含变长字符串
  - rows，行数，在Innodb中这个是个估计值，其他是精确值
  - avg_row_length，每行包含的字节数
  - data_length，表数据的大小
  - max_data_length，表数据的最大容量，表现为文件系统单个文件的大小
  - auto_increment，下一个自增值
  - create_time，创建时间
  - update_time，修改时间
  - check_time，使用check table命令的时间
  - collection，字符集和字符排序
  - checksum，整个表的实时校验和，这个开启会有性能影响吧，是吧每一行计算一个校验和，字段顺序不同也是有影响



1. MySQL可以再熟悉下，我们项目大多会用到。有本《高性能MySQL》不错，可以看看，重点看事务、索引page177相关章节，数据类型page147
2. 协程概念了解下
3. google的 protobuf
4. 证券相关知识
5. gRPC